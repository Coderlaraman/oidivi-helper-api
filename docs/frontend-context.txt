# .env.local

NEXT_PUBLIC_APP_NAME="OiDiVi Helper Web"
NEXT_PUBLIC_API_BASE_URL=http://oidivi-helper-api.test
NEXT_PUBLIC_LOCATIONIQ_API_KEY=pk.5f9c00d568a679fbcd7868136787c8b6
NEXT_PUBLIC_NOMINATIM_URL=https://nominatim.openstreetmap.org

# Laravel Echo Configuration
NEXT_PUBLIC_REVERB_APP_ID=827310
NEXT_PUBLIC_REVERB_APP_KEY=u8cxcnjsj80d9mbgexuh
NEXT_PUBLIC_REVERB_APP_SECRET=zi7xz8bnpo1dmhyllfxv
NEXT_PUBLIC_REVERB_HOST=localhost
NEXT_PUBLIC_REVERB_PORT=8080
NEXT_PUBLIC_REVERB_SCHEME=http


// '@/config/echo.ts'

import Echo from "laravel-echo";
import Pusher from "pusher-js";

/* eslint-disable no-unused-vars */
declare global {
  interface Window {
    Pusher: typeof Pusher;
  }
}
/* eslint-enable no-unused-vars */

// Definir el tipo específico para nuestra instancia de Echo
type EchoInstance = Echo<"reverb"> & {
  connector: {
    options: {
      auth: {
        headers: {
          Authorization: string;
        };
      };
    };
  };
};

let echoInstance: EchoInstance | null = null;

const getAuthToken = () => {
  if (typeof window !== "undefined") {
    return localStorage.getItem("user_auth_token");
  }
  return null;
};

const createEchoInstance = () => {
  if (typeof window !== "undefined" && !echoInstance) {
    window.Pusher = Pusher;

    echoInstance = new Echo({
      broadcaster: "reverb",
      key: process.env.NEXT_PUBLIC_REVERB_APP_KEY,
      wsHost: process.env.NEXT_PUBLIC_REVERB_HOST,
      wsPort: Number(process.env.NEXT_PUBLIC_REVERB_PORT) || 80,
      wssPort: Number(process.env.NEXT_PUBLIC_REVERB_PORT) || 443,
      forceTLS: false,
      enabledTransports: ["ws", "wss"],
      disableStats: true,
      authEndpoint: `${process.env.NEXT_PUBLIC_API_BASE_URL}/broadcasting/auth`,
      auth: {
        headers: {
          Accept: "application/json",
          Authorization: `Bearer ${getAuthToken()}`,
        },
      },
    }) as EchoInstance;
  }
  return echoInstance;
};

export const refreshEchoAuthToken = () => {
  const instance = createEchoInstance();
  if (instance?.connector) {
    instance.connector.options.auth.headers.Authorization = `Bearer ${getAuthToken()}`;
  }
};

// Exportar la instancia de Echo directamente
export default createEchoInstance();

// @/hooks/useEcho.ts

import { useEffect } from "react";
import echo, { refreshEchoAuthToken } from "@/config/echo";
import { useUserAuthContext } from "@/contexts/UserAuthContext";
import { EchoError } from "@/lib/types/echo";
import { toast } from "sonner";

export interface ServiceRequestNotification {
  id: string;
  type: string;
  timestamp: string;
  service_request: {
    id: number;
    title: string;
    slug: string;
    description: string;
    budget: number;
    priority: string;
    service_type: string;
    created_at: string;
  };
  notification: {
    title: string;
    message: string;
    action_url: string;
  };
}

export interface ServiceOfferNotification {
  id: string;
  type: string;
  timestamp: string;
  service_offer: {
    id: number;
    price_proposed: number;
    estimated_time: string;
    status: string;
    created_at: string;
    user: {
      id: number;
      name: string;
      profile_photo_url: string;
    };
    service_request: {
      id: number;
      title: string;
      slug: string;
    };
  };
  notification: {
    title: string;
    message: string;
    action_url: string;
  };
}

export interface ServiceOfferStatusNotification {
  id: string;
  type: string;
  timestamp: string;
  service_offer: {
    id: number;
    status: string;
    updated_at: string;
    service_request: {
      id: number;
      title: string;
      slug: string;
    };
  };
  notification: {
    title: string;
    message: string;
    action_url: string;
  };
}

export const useEcho = () => {
  const { isAuthenticated, user } = useUserAuthContext();

  useEffect(() => {
    // Solo intentamos conectar si estamos en el cliente y el usuario está autenticado
    if (typeof window === "undefined" || !isAuthenticated || !user || !echo) {
      return;
    }

    try {
      // Refrescar el token de autenticación antes de conectar
      refreshEchoAuthToken();

      // Suscribirse al canal privado de notificaciones del usuario
      const notificationChannel = echo.private(`user.notifications.${user.id}`);
      const privateChannel = echo.private(`user.${user.id}`);

      // Manejar eventos de conexión del canal privado
      privateChannel
        .error((error: EchoError) => {
          console.error("Error on private channel:", error);
          // Intentar reconectar si hay un error de autenticación
          if (error?.type === "AuthError") {
            refreshEchoAuthToken();
          }
        })
        .subscribed(() => {
          console.log("Subscribed to private channel");
        });

      // Manejar eventos de conexión del canal de notificaciones
      notificationChannel
        .error((error: EchoError) => {
          console.error("Error on notifications channel:", error);
          // Intentar reconectar si hay un error de autenticación
          if (error?.type === "AuthError") {
            refreshEchoAuthToken();
          }
        })
        .subscribed(() => {
          console.log("Subscribed to notifications channel");
        })
        // Notificación de nueva solicitud de servicio
        .listen(
          ".service.request.notification",
          (notification: ServiceRequestNotification) => {
            console.log(
              "New service request notification received:",
              notification
            );

            // Mostrar notificación toast
            toast(notification.notification.title, {
              description: notification.notification.message,
              action: {
                label: "Show details",
                onClick: () => {
                  // Usar el ID numérico del service_request para la redirección
                  const serviceId = notification.service_request.id;
                  window.location.href = `/service-requests/${serviceId}`;
                },
              },
              duration: 5000,
            });
          }
        )
        // Notificación de nueva oferta
        .listen(
          ".service.offer.notification",
          (notification: ServiceOfferNotification) => {
            console.log(
              "New service offer notification received:",
              notification
            );
            toast(notification.notification.title, {
              description: notification.notification.message,
              action: {
                label: "Show details",
                onClick: () => {
                  const { slug } = notification.service_offer.service_request;
                  const offerId = notification.service_offer.id;
                  window.location.href = `/service-requests/${slug}/offers/${offerId}`;
                },
              },
              duration: 5000,
            });
          }
        )
        // Notificación de actualización de estado de oferta
        .listen(
          ".service.offer.status.notification",
          (notification: ServiceOfferStatusNotification) => {
            console.log(
              "Service offer status update notification received:",
              notification
            );
            toast(notification.notification.title, {
              description: notification.notification.message,
              action: {
                label: "Show details",
                onClick: () => {
                  const { slug } = notification.service_offer.service_request;
                  const offerId = notification.service_offer.id;
                  window.location.href = `/service-requests/${slug}/offers/${offerId}`;
                },
              },
              duration: 5000,
            });
          }
        );

      // Cleanup function
      return () => {
        if (echo) {
          echo.leave(`private-user.${user.id}`);
          echo.leave(`private-user.notifications.${user.id}`);
        }
      };
    } catch (error) {
      console.error("Error initializing Echo:", error);
      // Intentar reconectar si hay un error
      refreshEchoAuthToken();
    }
  }, [isAuthenticated, user]);

  return echo;
};


// '@/lib/api/index.ts'

import axios, { AxiosError, AxiosRequestConfig, AxiosResponse } from "axios";
import { ApiErrorResponse, ApiResponse, User } from "@/lib/types/";

const API_BASE_URL =
  process.env.NEXT_PUBLIC_API_BASE_URL || "http://oidivi-helper-api.test";

const api = axios.create({
  baseURL: API_BASE_URL,
  headers: {
    "Content-Type": "application/json",
    Accept: "application/json",
  },
});

// Interceptor para añadir el token de autenticación a las peticiones
api.interceptors.request.use((config) => {
  const token = localStorage.getItem("user_auth_token");

  if (token && config.headers) {
    config.headers["Authorization"] = `Bearer ${token}`;
  }

  return config;
});

// Interceptor para manejar errores de respuesta
api.interceptors.response.use(
  (response) => response,
  (error: AxiosError<ApiErrorResponse>) => {
    if (error.response) {
      const status = error.response.status;

      if (status === 401) {
        localStorage.removeItem("user_auth_token");
        if (
          typeof window !== "undefined" &&
          !window.location.pathname.includes("/login")
        ) {
          window.location.href = "/login";
        }
      }

      if (status === 403) {
        // Acceso prohibido (email no verificado o permisos insuficientes)
      }
    }

    return Promise.reject(error);
  }
);

// Función genérica para realizar peticiones HTTP
export const apiRequest = async <T>(
  method: string,
  url: string,
  data?: unknown,
  config?: AxiosRequestConfig
): Promise<ApiResponse<T>> => {
  try {
    // Configurar timeout para detectar archivos grandes más rápido
    const requestConfig = {
      ...config,
      timeout: config?.timeout || 30000, // 30 segundos por defecto
    };

    let response: AxiosResponse;

    switch (method.toLowerCase()) {
      case "get":
        response = await api.get(url, requestConfig);
        break;
      case "post":
        response = await api.post(url, data, requestConfig);
        break;
      case "put":
        response = await api.put(url, data, requestConfig);
        break;
      case "patch":
        response = await api.patch(url, data, requestConfig);
        break;
      case "delete":
        response = await api.delete(url, requestConfig);
        break;
      default:
        throw new Error(`HTTP method not supported: ${method}`);
    }

    return response.data;
  } catch (error) {
    if (axios.isAxiosError(error)) {
      // Si hay una respuesta del servidor con errores de validación
      if (error.response) {
        // Detectar específicamente errores de validación de archivos grandes
        if (
          error.response.status === 413 ||
          (error.response.data?.errors &&
            error.response.data.errors.file &&
            error.response.data.errors.file.includes("The file is too large"))
        ) {
          return {
            success: false,
            message: "This file is too large.",
            data: {} as T,
            errors: {
              file: ["This file is too large."],
            },
          } as ApiResponse<T>;
        }

        // Devolver la respuesta de error del servidor
        return error.response.data as ApiResponse<T>;
      }

      // Detectar errores de timeout o conexión abortada (posiblemente por archivo grande)
      if (error.code === "ECONNABORTED" || error.message.includes("timeout")) {
        return {
          success: false,
          message: "The request is taking too long. Please try again later.",
          data: {} as T,
          errors: {
            file: ["The file is too large."],
          },
        } as ApiResponse<T>;
      }
    }

    // Error genérico de conexión
    return {
      success: false,
      message:
        "There was a problem connecting to the server. Please try again later.",
      data: {} as T,
    };
  }
};

// Tipos para la búsqueda
interface SearchParams {
  query?: string;
  category?: string;
  rating?: string;
  price?: string;
}

// Función para buscar usuarios
export const searchUsers = async (params: SearchParams) => {
  const queryString = new URLSearchParams();

  if (params.query) queryString.append("query", params.query);
  if (params.category) queryString.append("category", params.category);
  if (params.rating) queryString.append("rating", params.rating);
  if (params.price) queryString.append("price", params.price);

  return apiRequest<User[]>(
    "get",
    `/api/users/search?${queryString.toString()}`
  );
};

export default api;


// '@/lib/api/user/serviceOffers.ts'

import { apiRequest } from "@/lib/api";
import { ApiResponse } from "@/lib/types";

export interface ServiceOffer {
  id: number;
  service_request_id: number;
  user_id: number;
  price_proposed: number;
  estimated_time: string;
  message: string;
  status: string;
  created_at: string;
  updated_at: string;
  user: {
    id: number;
    name: string;
    email: string;
    profile_photo_url: string | null;
  };
  serviceRequest: {
    id: number;
    title: string;
    slug: string;
  };
}

export interface CreateServiceOfferData {
  price_proposed: number;
  estimated_time: string;
  message: string;
}

/**
 * Crea una nueva oferta para una solicitud de servicio.
 */
export const createServiceOffer = async (
  serviceRequestId: number,
  data: CreateServiceOfferData
): Promise<ApiResponse<ServiceOffer>> => {
  return apiRequest<ServiceOffer>(
    "post",
    `/api/v1/user/service-requests/${serviceRequestId}/offers`,
    data
  );
};

export const getServiceOffer = async (slug: string, offerId: string) => {
  return apiRequest<ServiceOffer>(
    "get",
    `/api/v1/user/service-requests/${slug}/offers/${offerId}`
  );
};

export const updateServiceOfferStatus = async (
  slug: string,
  offerId: string,
  status: string
) => {
  return apiRequest<ServiceOffer>(
    "put",
    `/api/v1/user/service-requests/${slug}/offers/${offerId}`,
    { status }
  );
};


